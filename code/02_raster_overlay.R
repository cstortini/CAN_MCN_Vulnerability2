#Spatial Intersections

library(sf)
library(dplyr)
library(raster)
library(ggplot2)
library(tidyr)
library(rnaturalearth)
library(patchwork)

sf_use_s2(FALSE) #makes some of the sf functions run a bit less buggy

#Projections ------------
latlong <- "+proj=longlat +datum=NAD83 +no_defs +ellps=GRS80 +towgs84=0,0,0"
CanProj <- "+proj=lcc +lat_1=49 +lat_2=77 +lat_0=63.390675 +lon_0=-91.86666666666666 +x_0=6200000 +y_0=3000000 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs"

#load polygons
can_eez <- read_sf("data/shapefiles/Canada_EEZ.shp")%>%st_transform(CanProj)

can_bioregions <- read_sf("data/shapefiles/DFO_Marine_Bioregions_Clipped_1M_CAEAC_2012_05_31.shp")%>%
  st_transform(CanProj)%>%
  rowwise()%>%
  mutate(region=as.character(Legend), #fix up the wierd format that the legends were captured
         region=strsplit(region,"/",fixed=TRUE)[[1]][1],
         region=gsub("\\.","",region),
         region=gsub("[0-9]+","",region),
         region=trimws(region))%>%
  filter(region != "Saint-Pierre et Miquelon")%>%
  ungroup()%>%
  st_as_sf()%>%
  rename(ocean=REGION)%>%
  filter(ocean != "Great Lakes")%>%
  dplyr::select(ocean,region,geometry)

mar_network <- read_sf("data/shapefiles/networksites_proposed_OEM_MPA_20220617.shp")%>%
  st_transform(CanProj)%>%
  mutate(type = ifelse(TYPE == "TBD","Draft",TYPE),
         type = ifelse(type == "OEM","OECM",type))%>%
  rename(mar_name = NAME,
         mar_type = type)%>% #easier name that doesn't overlap with other names from other dataframes
  dplyr::select(mar_name,mar_type,geometry)

mar_region <- read_sf("data/shapefiles/MaritimesPlanningArea.shp")%>%
  st_transform(CanProj)%>% #note this is slightly different than the bioregions but pretty close
  rename(mar_region=Name) #simplified name

can_mpas <- read_sf("data/shapefiles/DFO_MPA_MPO_ZPM.shp")%>%
  st_transform(CanProj)%>%
  mutate(type="MPA")%>%
  dplyr::select(NAME_E,type,geometry)

Canada <-  ne_states(country = "Canada",returnclass = "sf")%>%
  dplyr::select(name_en,geometry)%>%
  st_as_sf()%>%
  st_union()%>%
  st_transform(CanProj)%>%
  st_as_sf()%>%
  mutate(country="Canada")

#read in the Canadian OECMs and add in the newly announced Eastern Canyons - we can do this with rbind since the sf package treats data in a 'dataframe' approach. 
can_oecms <- rbind(
  
  read_sf("data/shapefiles/DFO_OEABCM_MPO_AMCEZ.shp")%>% #eastern canyons is missing
    st_transform(CanProj)%>%
    mutate(mar_type="OECM")%>%
    rename(type = mar_type)%>%
    dplyr::select(NAME_E,type,geometry),
  
  mar_network%>% #add in the Eastern Canyons
    filter(mar_name == "Eastern Canyons Marine Refuge")%>%
    rename(NAME_E = mar_name)%>%
    rename(type = mar_type)%>%
    dplyr::select(NAME_E,type,geometry)
  
)

#now add the whole dataset together for the Canadian Marine Conservation Network (MCN)
can_mcn <- rbind(can_mpas,can_oecms)

mar_network<-st_transform(mar_network, vuln.r@crs) ##Projection WGS84 code = 4326")
mar_region<-st_transform(mar_region, 4326) ##Projection WGS84 code = 4326")
can_mcn<-st_transform(can_mcn, 4326) ##Projection WGS84 code = 4326")

network_extent <- extent(mar_network)
#make a new mask that covers cells within and partially within a polygon - idea from here -https://gis.stackexchange.com/questions/255025/r-raster-masking-a-raster-by-polygon-also-remove-cells-partially-covered
network_raster_mask <- rasterize(mar_network,crop(vuln.r[[1]],network_extent,snap="out"),getCover=TRUE)
network_raster_mask[network_raster_mask == 0] <- NA
#apply the mask to the vuln raster using raster
vuln.extract <- vuln.r%>%
  crop(.,network_extent,snap="out")%>%
  raster::mask(.,network_raster_mask)
#now use sf and stars to extract the data
vuln_extract <- vuln.extract%>% #crop the raster to the extent of the PA
  st_as_stars()%>% #convert to stars raster brick
  st_as_sf()%>% #convert to sf dataframe
  st_transform(utm_mar)%>% #convert to planar coordinates for a more appropriate overlay
  st_intersection(.,mar_network%>%st_transform(utm_mar))%>%
  st_transform(st_crs(network_raster_mask))%>% #transform back to the raster brick projection
  mutate(cell_area=as.vector(st_area(.)/1000/1000),
         id = 1:n())%>% #calculate the area of the raster cells that are overlaid
  gather(.,"layer","temp",starts_with("layer."))%>% #convert to the long-form
  mutate(climate_proj=climate_proj)%>%
  dplyr::select(mod,climate_proj,species,year,month,NAME,STATUS,TYPE,cell_area,id,temp,geometry)%>%
  suppressWarnings()%>% #"attribute variables are assumed to be spatially constant throughout all geometries" - will clutter the output so it is suppressed
  data.frame()%>%
  dplyr::select(-geometry)

#   #save the data - this takes a while as the data is large
message(paste0("Saving output from ",mod," ",climate_proj,". This step does take a while because the output can be large."))
save(data_extract,file=paste0("output/grouped/climate_extracts_grouped_species_",tolower(mod),"_",gsub("\\.","-",climate_proj),".RData"))


#read in the datafiles and intersect with the Canadian MCN polys ** note we might want to buffer these to get values for the smallest sites
library(rasterize)
rcp_26 <- read.csv("data/climate_vulnerability_26.csv")
vuln<-rcp_26[,c(2,3,7)]
exp<-rcp_26[,c(2,3,6)]
sens<-rcp_26[,c(2,3,5)]
adcap<-rcp_26[,c(2,3,4)]
vuln.sd<-rcp_26[,c(2,3,11)]

#### RASTERIZE #####
colnames(vuln) <- c('x', 'y', 'vals')
colnames(sens) <- c('x', 'y', 'vals')
colnames(exp) <- c('x', 'y', 'vals')
colnames(adcap) <- c('x', 'y', 'vals')
colnames(vuln.sd) <- c('x', 'y', 'vals')

# create a raster object
r_obj <- raster(xmn=-180, xmx=180, ymn=-90, ymx=90, resolution=c(5,5))

# use rasterize to create desired raster
vuln.r <- rasterize(x=vuln[, 1:2], # lon-lat data
                    y=r_obj, # raster object
                    field=vuln[, 3], # vals to fill raster with
                    fun=mean) # aggregate function
exp.r <- rasterize(x=exp[, 1:2], # lon-lat data
                    y=r_obj, # raster object
                    field=exp[, 3], # vals to fill raster with
                    fun=mean) # aggregate function
sens.r <- rasterize(x=sens[, 1:2], # lon-lat data
                    y=r_obj, # raster object
                    field=sens[, 3], # vals to fill raster with
                    fun=mean) # aggregate function
adcap.r <- rasterize(x=adcap[, 1:2], # lon-lat data
                    y=r_obj, # raster object
                    field=adcap[, 3], # vals to fill raster with
                    fun=mean) # aggregate function
vulnsd.r <- rasterize(x=vuln.sd[, 1:2], # lon-lat data
                    y=r_obj, # raster object
                    field=vuln.sd[, 3], # vals to fill raster with
                    fun=mean) # aggregate function


polymeans <- raster::extract(vuln.r, mar_network, weights=TRUE, fun=mean)
vuln26 <- data.frame(mar_network$mar_name,mean.matrix)

results <- vector()  
for(j in 1:nrow(mar_network)) {
  lsub <- mar_network[j, ]
  cr <- raster::crop(vuln.r, raster::extent(lsub), snap = "out") 
  r <- as(cr, "SpatialPolygonsDataFrame")
  names(r@data) <- "raster.value"
  r <- intersect(lsub, r)
  na.idx <- which(is.na(r$raster.value))
  if(length(na.idx) > 0) { r <- r[-na.idx,] }
  if (nrow(r) < 1) {
    results <- append(results, NA)
  } else {
    results <- append(results, weighted.mean(r@data[,"raster.value"], gArea(r, byid=TRUE)))
  }
}
results
