#Spatial Intersections

library(sf)
library(dplyr)
library(raster)
library(ggplot2)
library(tidyr)
library(rnaturalearth)
library(patchwork)
library(stars)

sf_use_s2(FALSE) #makes some of the sf functions run a bit less buggy

#Projections ------------
latlong <- "+proj=longlat +datum=NAD83 +no_defs +ellps=GRS80 +towgs84=0,0,0"
CanProj <- "+proj=lcc +lat_1=49 +lat_2=77 +lat_0=63.390675 +lon_0=-91.86666666666666 +x_0=6200000 +y_0=3000000 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs"

#load vulnerability data and convert to rasters
library(rasterize)
rcp_26 <- read.csv("data/climate_vulnerability_26.csv")
rcp_85 <- read.csv("data/climate_vulnerability_85.csv")
vuln26<-rcp_26[,c(2,3,7)]
exp26<-rcp_26[,c(2,3,6)]
sens26<-rcp_26[,c(2,3,5)]
adcap26<-rcp_26[,c(2,3,4)]
vuln.sd26<-rcp_26[,c(2,3,11)]
vuln85<-rcp_85[,c(2,3,7)]
exp85<-rcp_85[,c(2,3,6)]
sens85<-rcp_85[,c(2,3,5)]
adcap85<-rcp_85[,c(2,3,4)]
vuln.sd85<-rcp_85[,c(2,3,11)]

#### RASTERIZE #####
colnames(vuln26) <- c('x', 'y', 'vals')
colnames(sens26) <- c('x', 'y', 'vals')
colnames(exp26) <- c('x', 'y', 'vals')
colnames(adcap26) <- c('x', 'y', 'vals')
colnames(vuln.sd26) <- c('x', 'y', 'vals')
colnames(vuln85) <- c('x', 'y', 'vals')
colnames(sens85) <- c('x', 'y', 'vals')
colnames(exp85) <- c('x', 'y', 'vals')
colnames(adcap85) <- c('x', 'y', 'vals')
colnames(vuln.sd85) <- c('x', 'y', 'vals')

# create a raster object
r_obj <- raster(xmn=-180, xmx=180, ymn=-90, ymx=90, resolution=c(5,5)) ### RYAN, IS THIS RESOLUTION FOR VULN DATA WRONG? Not sure how to fix this?

# use rasterize to create desired rasters
vuln.r26 <- rasterize(x=vuln26[, 1:2], # lon-lat data
                      y=r_obj, # raster object
                      field=vuln26[, 3], # vals to fill raster with
                      fun=mean) # aggregate function
exp.r26 <- rasterize(x=exp26[, 1:2],y=r_obj,field=exp26[, 3],fun=mean)
sens.r26 <- rasterize(x=sens26[, 1:2],y=r_obj,field=sens26[, 3],fun=mean)
adcap.r26 <- rasterize(x=adcap26[, 1:2],y=r_obj,field=adcap26[, 3],fun=mean)
vulnsd.r26 <- rasterize(x=vuln.sd26[, 1:2],y=r_obj,field=vuln.sd26[, 3],fun=mean)
vuln.r85 <- rasterize(x=vuln85[, 1:2],y=r_obj,field=vuln85[, 3],fun=mean)
exp.r85 <- rasterize(x=exp85[, 1:2],y=r_obj,field=exp85[, 3],fun=mean)
sens.r85 <- rasterize(x=sens85[, 1:2],y=r_obj,field=sens85[, 3],fun=mean)
adcap.r85 <- rasterize(x=adcap85[, 1:2],y=r_obj,field=adcap85[, 3],fun=mean)
vulnsd.r85 <- rasterize(x=vuln.sd85[, 1:2],y=r_obj,field=vuln.sd85[, 3],fun=mean)

#load conservation network polygons
can_eez <- read_sf("data/shapefiles/Canada_EEZ.shp")%>%st_transform(CanProj)

can_bioregions <- read_sf("data/shapefiles/DFO_Marine_Bioregions_Clipped_1M_CAEAC_2012_05_31.shp")%>%
  st_transform(CanProj)%>%
  rowwise()%>%
  mutate(region=as.character(Legend), #fix up the wierd format that the legends were captured
         region=strsplit(region,"/",fixed=TRUE)[[1]][1],
         region=gsub("\\.","",region),
         region=gsub("[0-9]+","",region),
         region=trimws(region))%>%
  filter(region != "Saint-Pierre et Miquelon")%>%
  ungroup()%>%
  st_as_sf()%>%
  rename(ocean=REGION)%>%
  filter(ocean != "Great Lakes")%>%
  dplyr::select(ocean,region,geometry)

mar_network <- read_sf("data/shapefiles/networksites_proposed_OEM_MPA_20220617.shp")%>%
  st_transform(CanProj)%>%
  mutate(type = ifelse(TYPE == "TBD","Draft",TYPE),
         type = ifelse(type == "OEM","OECM",type))%>%
  rename(mar_name = NAME,
         mar_type = type)%>% #easier name that doesn't overlap with other names from other dataframes
  dplyr::select(mar_name,mar_type,geometry)

mar_region <- read_sf("data/shapefiles/MaritimesPlanningArea.shp")%>%
  st_transform(CanProj)%>% #note this is slightly different than the bioregions but pretty close
  rename(mar_region=Name) #simplified name

can_mpas <- read_sf("data/shapefiles/DFO_MPA_MPO_ZPM.shp")%>%
  st_transform(CanProj)%>%
  mutate(type="MPA")%>%
  dplyr::select(NAME_E,type,geometry)

Canada <-  ne_states(country = "Canada",returnclass = "sf")%>%
  dplyr::select(name_en,geometry)%>%
  st_as_sf()%>%
  st_union()%>%
  st_transform(CanProj)%>%
  st_as_sf()%>%
  mutate(country="Canada")

#read in the Canadian OECMs and add in the newly announced Eastern Canyons - we can do this with rbind since the sf package treats data in a 'dataframe' approach. 
can_oecms <- rbind(
  
  read_sf("data/shapefiles/DFO_OEABCM_MPO_AMCEZ.shp")%>% #eastern canyons is missing
    st_transform(CanProj)%>%
    mutate(mar_type="OECM")%>%
    rename(type = mar_type)%>%
    dplyr::select(NAME_E,type,geometry),
  
  mar_network%>% #add in the Eastern Canyons
    filter(mar_name == "Eastern Canyons Marine Refuge")%>%
    rename(NAME_E = mar_name)%>%
    rename(type = mar_type)%>%
    dplyr::select(NAME_E,type,geometry)
  
)

#now combine for the Canadian Marine Conservation Network (MCN)
can_mcn <- rbind(can_mpas,can_oecms)

#change the projection to match vulnerability rasters
mar_network<-st_transform(mar_network, vuln.r26@crs) ##Projection WGS84 code = 4326")
mar_region<-st_transform(mar_region, vuln.r26@crs) ##Projection WGS84 code = 4326")
can_mcn<-st_transform(can_mcn, vuln.r26@crs) ##Projection WGS84 code = 4326")

network_extent <- extent(mar_network) #for SS-BoF network only first

#make a new mask that covers cells within and partially within a polygon - idea from here -https://gis.stackexchange.com/questions/255025/r-raster-masking-a-raster-by-polygon-also-remove-cells-partially-covered
#only need to do this for one of the rasters as they all have the same number of cells, cell size, etc.
network_raster_mask <- rasterize(mar_network,crop(vuln.r26[[1]],network_extent,snap="out"),getCover=TRUE)
network_raster_mask[network_raster_mask == 0] <- NA

x<-list(vuln26=vuln.r26,sens26=sens.r26,adcap26=adcap.r26,vulnsd26=vulnsd.r26,vuln85=vuln.r85,sens85=sens.r85,adcap85=adcap.r85,vulnsd85=vulnsd.r85)
#apply the mask to the vuln rasters using raster
fn<-function(x){vuln.extract <- x%>%
  crop(.,network_extent,snap="out")%>% #crop the raster to the extent of the PA
  raster::mask(.,network_raster_mask)
#now use sf and stars to extract the data
vuln_extract <- vuln.extract%>% 
  st_as_stars()%>% #convert to stars raster brick
  st_as_sf()%>% #convert to sf dataframe
  st_transform(4326)%>% #convert to planar coordinates for a more appropriate overlay
  st_intersection(.,mar_network%>%st_transform(4326))%>%
  st_transform(st_crs(network_raster_mask))%>% #transform back to the raster projection
  mutate(cell_area=as.vector(st_area(.)/1000/1000),
         id = 1:n())%>% #calculate the area of the raster cells that are overlaid
  dplyr::select(mar_name,mar_type,cell_area,id,layer)%>%
  suppressWarnings()%>% #"attribute variables are assumed to be spatially constant throughout all geometries" - will clutter the output so it is suppressed
  data.frame()%>%
  rename(.,value=layer)%>%
  dplyr::select(-geometry)}
vulns<-lapply(x,fn)
my_list <- Map(cbind, vulns, var = names(vulns))
all_df <- do.call("rbind", my_list)
substrRight <- function(x, n){
  substr(x, nchar(x)-n+1, nchar(x))}
all_df$rcp<-substrRight(all_df$var, 2)
all_df$var<-substr(all_df$var,1,nchar(all_df$var)-2)
write.csv(all_df, "output/SSBoF_draftnetwork_vulns_cells.csv", row.names = FALSE)


######################################################
#### Now do it again for the full Canadian network ###
can_network_extent <- extent(can_mcn)
can_raster_mask <- rasterize(can_mcn,crop(vuln.r26[[1]],can_network_extent,snap="out"),getCover=TRUE)
can_raster_mask[can_raster_mask == 0] <- NA

x<-list(vuln26=vuln.r26,sens26=sens.r26,adcap26=adcap.r26,vulnsd26=vulnsd.r26,vuln85=vuln.r85,sens85=sens.r85,adcap85=adcap.r85,vulnsd85=vulnsd.r85)
#apply the mask to the vuln rasters using raster
fn<-function(x){vuln.extract <- x%>%
  crop(.,can_network_extent,snap="out")%>% #crop the raster to the extent of the PA
  raster::mask(.,can_raster_mask)
#now use sf and stars to extract the data
vuln_extract <- vuln.extract%>% 
  st_as_stars()%>% #convert to stars raster brick
  st_as_sf()%>% #convert to sf dataframe
  st_transform(4326)%>% #convert to planar coordinates for a more appropriate overlay
  st_intersection(.,can_mcn%>%st_transform(4326))%>%
  st_transform(st_crs(can_raster_mask))%>% #transform back to the raster projection
  mutate(cell_area=as.vector(st_area(.)/1000/1000),
         id = 1:n())%>% #calculate the area of the raster cells that are overlaid
  dplyr::select(NAME_E,type,cell_area,id,layer)%>%
  suppressWarnings()%>% #"attribute variables are assumed to be spatially constant throughout all geometries" - will clutter the output so it is suppressed
  data.frame()%>%
  rename(.,value=layer)%>%
  dplyr::select(-geometry)}
vulns<-lapply(x,fn)
my_list <- Map(cbind, vulns, var = names(vulns))
all_df <- do.call("rbind", my_list)
substrRight <- function(x, n){
  substr(x, nchar(x)-n+1, nchar(x))}
all_df$rcp<-substrRight(all_df$var, 2)
all_df$var<-substr(all_df$var,1,nchar(all_df$var)-2)
write.csv(all_df, "output/canada_mcn_vulns_cells.csv", row.names = FALSE)

#### ^ Use the above to look at all cell scores in sites (note that cell_area tells you the area of the cell with that score that is within the bounds of the site)
#### Use below for average scores per site.. can calculate standard error to create error bars around the mean using 95% Confidence Intervals

#######################################################
### Calculate area-weighted average scores per site ###
canmcn<-read.csv("output/canada_mcn_vulns_cells.csv")
ssbofmcn<-read.csv("output/SSBoF_draftnetwork_vulns_cells.csv")

fun<-function(x){data.frame(val=weighted.mean(x$value, x$cell_area))}

names(canmcn)
can.avs<-canmcn %>% group_by(NAME_E,type,var,rcp) %>% do(fun(.))
write.csv(can.avs,"output/avscores_can_mcn.csv")

names(ssbofmcn)
ssbof.avs<-ssbofmcn %>% group_by(mar_name,mar_type,var,rcp) %>% do(fun(.))
write.csv(ssbof.avs,"output/avscores_ssbof_mcn.csv")
