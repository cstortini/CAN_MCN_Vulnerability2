##load libraries
library(sf)
library(dplyr)
library(raster)
library(ggplot2)
library(tidyr)
library(rnaturalearth)
library(patchwork)
library(stars)
library(rasterize)
library(fasterize)

sf_use_s2(FALSE) #makes some of the sf functions run a bit less buggy

#Projections ------------
latlong <- "+proj=longlat +datum=NAD83 +no_defs +ellps=GRS80 +towgs84=0,0,0"
CanProj <- "+proj=lcc +lat_1=49 +lat_2=77 +lat_0=63.390675 +lon_0=-91.86666666666666 +x_0=6200000 +y_0=3000000 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs"

#load conservation network polygons ---------
can_eez <- read_sf("data/shapefiles/Canada_EEZ.shp")%>%st_transform(CanProj)

can_bioregions <- read_sf("data/shapefiles/DFO_Marine_Bioregions_Clipped_1M_CAEAC_2012_05_31.shp")%>%
  st_transform(CanProj)%>%
  rowwise()%>%
  mutate(region=as.character(Legend), #fix up the wierd format that the legends were captured
         region=strsplit(region,"/",fixed=TRUE)[[1]][1],
         region=gsub("\\.","",region),
         region=gsub("[0-9]+","",region),
         region=trimws(region))%>%
  filter(region != "Saint-Pierre et Miquelon")%>%
  ungroup()%>%
  st_as_sf()%>%
  rename(ocean=REGION)%>%
  filter(ocean != "Great Lakes")%>%
  dplyr::select(ocean,region,geometry)

mar_network1 <- read_sf("data/shapefiles/networksites_proposed_OEM_MPA_20220617.shp")%>%
  st_transform(CanProj)%>%
  mutate(type = ifelse(TYPE == "TBD","Draft",TYPE),
         type = ifelse(type == "OEM","OECM",type))%>%
  rename(mar_name = NAME,
         mar_type = type)%>% #easier name that doesn't overlap with other names from other dataframes
  dplyr::select(mar_name,mar_type,geometry)

mar_network <- mar_network1%>%
  group_by(mar_name)%>%
  summarise(geometry=st_union(geometry))%>% # to unify the Western Emerald Bank Polygon
  ungroup()%>%
  st_as_sf()%>%
  left_join(.,mar_network1%>%
              data.frame()%>%
              dplyr::select(-geometry)%>%
              distinct(mar_name,.keep_all=T))

mar_region <- read_sf("data/shapefiles/MaritimesPlanningArea.shp")%>%
  st_transform(CanProj)%>% #note this is slightly different than the bioregions but pretty close
  rename(mar_region=Name) #simplified name

can_mpas <- read_sf("data/shapefiles/DFO_MPA_MPO_ZPM.shp")%>%
  st_transform(CanProj)%>%
  mutate(NAME_E = ifelse(grepl("Eastport",NAME_E),"Eastport Marine Protected Area",NAME_E))%>%# Eastport has two names for the two pieces for some reason
  group_by(NAME_E)%>%
  summarise(geometry=st_union(geometry))%>%
  ungroup()%>%
  st_as_sf()%>%
  mutate(type="MPA")%>%
  dplyr::select(NAME_E,type,geometry)

Canada <-  ne_states(country = "Canada",returnclass = "sf")%>%
  dplyr::select(name_en,geometry)%>%
  st_as_sf()%>%
  st_union()%>%
  st_transform(CanProj)%>%
  st_as_sf()%>%
  mutate(country="Canada")

#read in the Canadian OECMs and add in the newly announced Eastern Canyons - we can do this with rbind since the sf package treats data in a 'dataframe' approach. 
can_oecms <- rbind(
  
  read_sf("data/shapefiles/DFO_OEABCM_MPO_AMCEZ.shp")%>% #eastern canyons is missing
    st_transform(CanProj)%>%
    mutate(mar_type="OECM")%>%
    rename(type = mar_type)%>%
    dplyr::select(NAME_E,type,geometry),
  
  mar_network%>% #add in the Eastern Canyons
    filter(mar_name == "Eastern Canyons Marine Refuge")%>%
    rename(NAME_E = mar_name)%>%
    rename(type = mar_type)%>%
    dplyr::select(NAME_E,type,geometry)
  
)

can_oecms_regions <- can_oecms%>%
  st_centroid()%>%
  st_join(.,can_bioregions)%>% #the centroids for Musquash/Gilbert Bay are on land based on the resoluiton of the bioregions and Anguniaqvia centroid is on land
  data.frame()%>%
  dplyr::select(NAME_E,type,ocean,region)

#now combine for the Canadian Marine Conservation Network (MCN)
can_mcn <- rbind(can_mpas,can_oecms)

#identify the regions assocaited with each MPA for later analysis. 
can_mcn_regions <- can_mcn%>%
                    st_centroid()%>%
                    st_join(.,can_bioregions,join=st_is_within_distance,dist=10000)%>% #the centroids for Musquash/Gilbert Bay are on land based on the resoluiton of the bioregions and Anguniaqvia centroid is on land
                    st_transform(latlong)%>%
                    mutate(lat=st_coordinates(.)[,2],
                           long=st_coordinates(.)[,1])%>%
                    data.frame()%>%
                    mutate(ocean = ifelse(NAME_E == "Saguenay Fjord Upstream closure","Atlantic",ocean), 
                           region = ifelse(NAME_E == "Saguenay Fjord Upstream closure","Gulf of Saint Lawrence",region))%>%# Saguenay Fjord Upstream closure centriod is  far inland and outside the polygon
                    arrange(ocean,region,lat)%>%
                    dplyr::select(NAME_E,type,ocean,region,lat,long)

#load the datasets to be rasterized ------
rcp_26 <- read.csv("data/climate_vulnerability_26.csv")
rcp_85 <- read.csv("data/climate_vulnerability_85.csv")
bathy <- read.csv("data/bathy.csv")%>%
        mutate(bathy = ifelse(bathy>0,NA,bathy))

#set limits for the raster based on the limits of the two datasets
lat_lim <- c(min(c(rcp_26$lat,bathy$lat)),max(c(rcp_26$lat,bathy$lat)))
lon_lim <- c(min(c(rcp_26$lon,bathy$lon)),max(c(rcp_26$lon,bathy$lon)))

#create an empty raster to be used in the rasterize process for a 0.25 degree raster
ras_dummy <-expand.grid(lon=seq(lon_lim[1],lon_lim[2],0.25),
                        lat=seq(lat_lim[1],lat_lim[2],0.25))%>%
            rasterFromXYZ(.,crs = latlong)

#now create a raster brick for the different values for each variable
raster_names <- names(rcp_26)[4:length(rcp_26)]

#RCP 2.6
rcp_26_stack <- list()
for (i in raster_names){
  rcp_26_stack[[i]] <- rasterize(x=rcp_26[,c("lon","lat")], # lon-lat data
                                  y=ras_dummy, # raster object
                                  field=rcp_26[,i], # vals to fill raster with
                                  fun=mean)
  
}

#RCP 8.5
rcp_85_stack <- list()
for (i in raster_names){
  rcp_85_stack[[i]] <- rasterize(x=rcp_85[,c("lon","lat")], # lon-lat data
                                 y=ras_dummy, # raster object
                                 field=rcp_85[,i], # vals to fill raster with
                                 fun=mean)
  
}

#bathymetry
rcp_26_stack[["bathy"]] <- rasterize(x=bathy[,c("lon","lat")], # lon-lat data
                                     y=ras_dummy, # raster object
                                     field=bathy[,"bathy"], # vals to fill raster with
                                     fun=mean)
                            

rcp_85_stack[["bathy"]] <- rasterize(x=bathy[,c("lon","lat")], # lon-lat data
                                     y=ras_dummy, # raster object
                                     field=bathy[,"bathy"], # vals to fill raster with
                                     fun=mean)

#convert to raster bricks
rcp_26_brick <- rcp_26_stack%>%brick()
rcp_85_brick <- rcp_85_stack%>%brick()

#do the intersections ----------

  # #raster 'mask' for the bioregions
 bioregion_extent <- extent(can_bioregions%>%st_transform(latlong))
  #   bioregion_raster_mask <- rasterize(can_bioregions%>%st_transform(latlong)%>%as_Spatial(),crop(rcp_26_stack[[1]],bioregion_extent,snap="out"),getCover=TRUE)
  #   bioregion_raster_mask[bioregion_raster_mask == 0] <- NA
  # 
  # #raster 'mask' for the Canadain MPA network
  network_extent <- extent(can_mcn%>%st_transform(latlong))
     # network_raster_mask <- rasterize(can_mcn%>%st_transform(latlong)%>%as_Spatial(),crop(rcp_26_stack[[1]],network_extent,snap="out"),getCover=TRUE)
     # network_raster_mask[network_raster_mask == 0] <- NA
  # 
  # #raster 'mask' for the Scotian Shelf-Bay of Fundy Bioregion
  network_extent_mar <- extent(mar_network%>%st_transform(latlong))
  #   network_raster_mask_mar <- rasterize(mar_network%>%st_transform(latlong)%>%as_Spatial(),crop(rcp_26_stack[[1]],network_extent_mar,snap="out"),getCover=TRUE)
  #   network_raster_mask_mar[network_raster_mask_mar == 0] <- NA
  
  #save the rasters so you don't have to re-create them each time
    save(bioregion_raster_mask,network_raster_mask,network_raster_mask_mar,file="output/network_raster_masks.RData")
  
  #load the raster masks (if they are already created and you don't want to re-create)
    load("output/network_raster_masks.RData")

#extractions for the Canadian bioregions-this takes a while (because stars is slow -- so we will do it in two peices and rbind them at the end. )
    bioregion_extract_26 <- rcp_26_stack%>%
                         brick()%>%#convert to raster 'brick'
                         crop(.,bioregion_extent)%>%
                         raster::mask(bioregion_raster_mask)%>%
                         st_as_stars()%>% #convert to stars raster brick
                         st_as_sf()%>% #convert to sf dataframe
                         st_transform(4326)%>%
                         st_intersection(.,can_bioregions%>%st_transform(4326)%>%st_make_valid())%>%
                         st_transform(latlong)%>% #transform back to the raster projection
                         mutate(cell_area=as.vector(st_area(.)/1000/1000),
                                 id = 1:n(),rcp=2.6)

    bioregion_extract_85 <- rcp_85_stack%>%
                            brick()%>%#convert to raster 'brick'
                            crop(.,bioregion_extent)%>%
                            raster::mask(bioregion_raster_mask)%>%
                            st_as_stars()%>% #convert to stars raster brick
                            st_as_sf()%>% #convert to sf dataframe
                            st_transform(4326)%>%
                            st_intersection(.,can_bioregions%>%st_transform(4326)%>%st_make_valid())%>%
                            st_transform(latlong)%>% #transform back to the raster projection
                            mutate(cell_area=as.vector(st_area(.)/1000/1000),
                                   id = 1:n(),rcp=2.6)

    #bind it together
    bioregion_extract <- rbind(bioregion_extract_26,bioregion_extract_85)
    
    #save the outputs
    save(bioregion_extract,file="output/bioregion_extract.RData")
    
    load("output/bioregion_extract.RData")

#extractions for the national network ----------------
    
    #do the extractions for the bioregions that contain each conservation closure but exclude the area that is in the closure (this is akin to Dan's thoughts re: analysis later)
    can_network_combo <- can_mcn%>%
                          st_transform(CanProj)%>%
                          st_buffer(2)%>%
                          st_combine()%>%
                          st_make_valid()%>%
                          st_transform(4326)
    
    region_invert_extracts <- NULL
    
    for(i in unique(can_bioregions$region)){
      
      message(paste0("Working on ",i," bioregion"))
      
      temp_sites <- can_mcn_regions%>%filter(region==i)%>%pull(NAME_E) #sites in the focal region (i)
      
      region_network_temp <- can_mcn%>%
        filter(NAME_E %in% temp_sites)%>%
        st_transform(CanProj)%>%
        st_buffer(2)%>%
        st_combine()%>%
        st_make_valid()%>%
        st_transform(4326)
      
      #the arctic Basin region has some overlap issues whereby the only MPA is not contained fully within the bioregion we need to combine them to make this work 
            # ggplot()+
            #   geom_sf(data=can_mcn%>%filter(NAME_E == "Tuvaijuittuq Marine Protected Area"),fill="red")+
            #   geom_sf(data=can_bioregions%>%filter(region=="Arctic Basin"))
      
      if(i == "Arctic Basin"){
        
        region_temp <- can_bioregions%>%
          filter(region == i)%>%
          dplyr::select(geometry)%>%
          rbind(.,can_mcn%>%filter(NAME_E == "Tuvaijuittuq Marine Protected Area")%>%dplyr::select(geometry))%>%
          st_combine()%>%
          st_make_valid()%>%
          st_buffer(0.5)%>%
          st_transform(4326)%>%
          st_difference(.,region_network_temp%>%st_make_valid())%>% #get the invert of the region
          st_transform(latlong)%>%
          st_as_sf()%>%
          mutate(ocean="Arctic",region="Arctic Basin")
        
      }
     
      if(i != "Arctic Basin" ){
      region_temp <- can_bioregions%>%
                     filter(region == i)%>%
                     st_make_valid()%>%
                     st_transform(4326)%>%
                     st_difference(.,region_network_temp%>%st_make_valid())%>% #get the invert of the region
                     st_transform(latlong)
      }
      
      
      region_temp_mask <- region_temp%>%
                          as_Spatial()%>%
                          rasterize(.,crop(rcp_26_stack[[1]],extent(can_bioregions%>%filter(region == i)%>%st_transform(latlong)),snap="out"),getCover=TRUE)
      
      region_temp_mask[region_temp_mask == 0] <- NA
      
      region_temp_extract_26 <- rcp_26_stack%>%
                                brick()%>%#convert to raster 'brick'
                                crop(.,region_temp_mask%>%extent())%>%
                                raster::mask(region_temp_mask)%>%
                                st_as_stars()%>% #convert to stars raster brick
                                st_as_sf()%>% #convert to sf dataframe
                                st_transform(4326)%>%
                                st_intersection(.,region_temp%>%st_transform(4326))%>%
                                st_transform(latlong)%>% #transform back to the raster projection
                                mutate(cell_area=as.vector(st_area(.)/1000/1000),
                                       id = 1:n(),rcp=2.6,location="outside")
      
      region_temp_extract_85 <- rcp_85_stack%>%
                                brick()%>%#convert to raster 'brick'
                                crop(.,region_temp_mask%>%extent())%>%
                                raster::mask(region_temp_mask)%>%
                                st_as_stars()%>% #convert to stars raster brick
                                st_as_sf()%>% #convert to sf dataframe
                                st_transform(4326)%>%
                                st_intersection(.,region_temp%>%st_transform(4326))%>%
                                st_transform(latlong)%>% #transform back to the raster projection
                                mutate(cell_area=as.vector(st_area(.)/1000/1000),
                                       id = 1:n(),rcp=8.5,location="outside")
      
      #rbind the outputs into one big dataframe. This is the slowest way to do it but hopefully it is intuitive. 
      region_invert_extracts <- rbind(region_invert_extracts,region_temp_extract_26,region_temp_extract_85)
    }
    
    #extract the networks inside conservation areas within each region
    can_network_inside_26 <- rcp_26_stack%>%
                              brick()%>%#convert to raster 'brick'
                              crop(.,network_raster_mask%>%extent())%>%
                              raster::mask(network_raster_mask)%>%
                              st_as_stars()%>% #convert to stars raster brick
                              st_as_sf()%>% #convert to sf dataframe
                              st_transform(4326)%>%
                              st_intersection(.,can_mcn%>%st_transform(4326))%>%
                              st_transform(latlong)%>% #transform back to the raster projection
                              mutate(cell_area=as.vector(st_area(.)/1000/1000),
                                     id = 1:n(),rcp=2.6,location="inside")

    can_network_inside_85 <- rcp_85_stack%>%
                              brick()%>%#convert to raster 'brick'
                              crop(.,network_raster_mask%>%extent())%>%
                              raster::mask(network_raster_mask)%>%
                              st_as_stars()%>% #convert to stars raster brick
                              st_as_sf()%>% #convert to sf dataframe
                              st_transform(4326)%>%
                              st_intersection(.,can_mcn%>%st_transform(4326))%>%
                              st_transform(latlong)%>% #transform back to the raster projection
                              mutate(cell_area=as.vector(st_area(.)/1000/1000),
                                     id = 1:n(),rcp=8.5,location="inside")

    
    #now combine it all together
    can_network_extract <- rbind(can_network_inside_26,can_network_inside_85)%>%
                           left_join(.,can_mcn_regions%>%dplyr::select(-c(lat,long)))
    
    can_mcn_extracts <- rbind(can_network_extract,
                              region_invert_extracts%>%
                                mutate(type=NA,NAME_E=NA)%>%
                                dplyr::select(names(can_network_extract)))

    #save the outputs
    save(can_mcn_extracts,file="output/can_network_extract.RData")

  #extractions for the Scotian Shelf-Bay of Fundy Draft Network -------------
    #make a single polygon for the network
    mar_network_combo <- mar_network%>%
                         st_transform(CanProj)%>%
                         st_buffer(2)%>%
                         st_combine()%>%
                         st_make_valid()%>%
                         st_transform(4326)

    #carve out the difference between the region and the network (holes where MPAs are)
    mar_network_invert <- mar_region%>%
                          st_transform(4326)%>%
                          st_difference(.,mar_network_combo)%>%
                          st_transform(latlong)

    mar_network_invert_mask <- mar_network_invert%>%
                                as_Spatial()%>%
                                rasterize(.,crop(rcp_26_stack[[1]],extent(mar_region%>%st_transform(latlong)),snap="out"),getCover=TRUE)

    mar_network_invert_mask[mar_network_invert_mask == 0] <- NA

    #now extract for the 'inside' and 'outside' of the MAR network
    mar_network_outside_26 <- rcp_26_stack%>%
                             brick()%>%#convert to raster 'brick'
                             crop(.,mar_network_invert_mask%>%extent())%>%
                             raster::mask(mar_network_invert_mask)%>%
                             st_as_stars()%>% #convert to stars raster brick
                             st_as_sf()%>% #convert to sf dataframe
                             st_transform(4326)%>%
                             st_intersection(.,mar_network_invert)%>%
                             st_transform(latlong)%>% #transform back to the raster projection
                             mutate(cell_area=as.vector(st_area(.)/1000/1000),
                                       id = 1:n(),rcp=2.6,location="outside")

    mar_network_outside_85 <- rcp_85_stack%>%
                              brick()%>%#convert to raster 'brick'
                              crop(.,mar_network_invert_mask%>%extent())%>%
                              raster::mask(mar_network_invert_mask)%>%
                              st_as_stars()%>% #convert to stars raster brick
                              st_as_sf()%>% #convert to sf dataframe
                              st_transform(4326)%>%
                              st_intersection(.,mar_network_invert)%>%
                              st_transform(latlong)%>% #transform back to the raster projection
                              mutate(cell_area=as.vector(st_area(.)/1000/1000),
                                     id = 1:n(),rcp=8.5,location="outside")

    mar_network_inside_26 <- rcp_26_stack%>%
                              brick()%>%#convert to raster 'brick'
                              crop(.,network_raster_mask_mar%>%extent())%>%
                              raster::mask(network_raster_mask_mar)%>%
                              st_as_stars()%>% #convert to stars raster brick
                              st_as_sf()%>% #convert to sf dataframe
                              st_transform(4326)%>%
                              st_intersection(.,mar_network%>%st_transform(4326))%>%
                              st_transform(latlong)%>% #transform back to the raster projection
                              mutate(cell_area=as.vector(st_area(.)/1000/1000),
                                     id = 1:n(),rcp=2.6,location="inside")

    mar_network_inside_85 <- rcp_85_stack%>%
                              brick()%>%#convert to raster 'brick'
                              crop(.,network_raster_mask_mar%>%extent())%>%
                              raster::mask(network_raster_mask_mar)%>%
                              st_as_stars()%>% #convert to stars raster brick
                              st_as_sf()%>% #convert to sf dataframe
                              st_transform(4326)%>%
                              st_intersection(.,mar_network%>%st_transform(4326))%>%
                              st_transform(latlong)%>% #transform back to the raster projection
                              mutate(cell_area=as.vector(st_area(.)/1000/1000),
                                     id = 1:n(),rcp=8.5,location="inside")

    #combine the data together
    mar_network_extract <- rbind(mar_network_inside_26,mar_network_outside_26%>%rename(mar_name=mar_region)%>%mutate(mar_type="region")%>%dplyr::select(names(mar_network_inside_26)),
                                 mar_network_inside_85,mar_network_outside_85%>%rename(mar_name=mar_region)%>%mutate(mar_type="region")%>%dplyr::select(names(mar_network_inside_85)))
    
    #save the output to reduce computational time
    save(mar_network_extract,file="output/mar_network_extract.RData")
    
    #to viz how this has worked 
    ggplot()+geom_sf(data=mar_network_extract,aes(fill=location))
    
